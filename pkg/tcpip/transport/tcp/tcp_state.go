// automatically generated by stateify.

package tcp

import (
	"gvisor.googlesource.com/gvisor/pkg/state"
)

func (x *endpointState) save(m state.Map) {
	m.SaveValue("", (int)(*x))
}

func (x *endpointState) load(m state.Map) {
	m.LoadValue("", new(int), func(y interface{}) { *x = (endpointState)(y.(int)) })
}

func (x *SACKInfo) beforeSave() {}
func (x *SACKInfo) save(m state.Map) {
	x.beforeSave()
	m.Save("Blocks", &x.Blocks)
	m.Save("NumBlocks", &x.NumBlocks)
}

func (x *SACKInfo) afterLoad() {}
func (x *SACKInfo) load(m state.Map) {
	m.Load("Blocks", &x.Blocks)
	m.Load("NumBlocks", &x.NumBlocks)
}

func (x *endpoint) save(m state.Map) {
	x.beforeSave()
	if !state.IsZeroValue(x.segmentQueue) { m.Failf("segmentQueue is %v, expected zero", x.segmentQueue) }
	if !state.IsZeroValue(x.notifyFlags) { m.Failf("notifyFlags is %v, expected zero", x.notifyFlags) }
	var acceptedChan endpointChan = x.saveAcceptedChan()
	m.SaveValue("acceptedChan", acceptedChan)
	m.Save("netProto", &x.netProto)
	m.Save("waiterQueue", &x.waiterQueue)
	m.Save("lastError", &x.lastError)
	m.Save("rcvList", &x.rcvList)
	m.Save("rcvClosed", &x.rcvClosed)
	m.Save("rcvBufSize", &x.rcvBufSize)
	m.Save("rcvBufUsed", &x.rcvBufUsed)
	m.Save("id", &x.id)
	m.Save("state", &x.state)
	m.Save("isPortReserved", &x.isPortReserved)
	m.Save("isRegistered", &x.isRegistered)
	m.Save("boundNICID", &x.boundNICID)
	m.Save("v6only", &x.v6only)
	m.Save("isConnectNotified", &x.isConnectNotified)
	m.Save("effectiveNetProtos", &x.effectiveNetProtos)
	m.Save("hardError", &x.hardError)
	m.Save("workerRunning", &x.workerRunning)
	m.Save("workerCleanup", &x.workerCleanup)
	m.Save("sendTSOk", &x.sendTSOk)
	m.Save("recentTS", &x.recentTS)
	m.Save("tsOffset", &x.tsOffset)
	m.Save("shutdownFlags", &x.shutdownFlags)
	m.Save("sackPermitted", &x.sackPermitted)
	m.Save("sack", &x.sack)
	m.Save("noDelay", &x.noDelay)
	m.Save("reuseAddr", &x.reuseAddr)
	m.Save("sndBufSize", &x.sndBufSize)
	m.Save("sndBufUsed", &x.sndBufUsed)
	m.Save("sndClosed", &x.sndClosed)
	m.Save("sndBufInQueue", &x.sndBufInQueue)
	m.Save("sndQueue", &x.sndQueue)
	m.Save("packetTooBigCount", &x.packetTooBigCount)
	m.Save("sndMTU", &x.sndMTU)
	m.Save("rcv", &x.rcv)
	m.Save("snd", &x.snd)
}

func (x *endpoint) load(m state.Map) {
	m.Load("netProto", &x.netProto)
	m.Load("waiterQueue", &x.waiterQueue)
	m.Load("lastError", &x.lastError)
	m.Load("rcvList", &x.rcvList)
	m.Load("rcvClosed", &x.rcvClosed)
	m.Load("rcvBufSize", &x.rcvBufSize)
	m.Load("rcvBufUsed", &x.rcvBufUsed)
	m.Load("id", &x.id)
	m.Load("state", &x.state)
	m.Load("isPortReserved", &x.isPortReserved)
	m.Load("isRegistered", &x.isRegistered)
	m.Load("boundNICID", &x.boundNICID)
	m.Load("v6only", &x.v6only)
	m.Load("isConnectNotified", &x.isConnectNotified)
	m.Load("effectiveNetProtos", &x.effectiveNetProtos)
	m.Load("hardError", &x.hardError)
	m.Load("workerRunning", &x.workerRunning)
	m.Load("workerCleanup", &x.workerCleanup)
	m.Load("sendTSOk", &x.sendTSOk)
	m.Load("recentTS", &x.recentTS)
	m.Load("tsOffset", &x.tsOffset)
	m.Load("shutdownFlags", &x.shutdownFlags)
	m.Load("sackPermitted", &x.sackPermitted)
	m.Load("sack", &x.sack)
	m.Load("noDelay", &x.noDelay)
	m.Load("reuseAddr", &x.reuseAddr)
	m.Load("sndBufSize", &x.sndBufSize)
	m.Load("sndBufUsed", &x.sndBufUsed)
	m.Load("sndClosed", &x.sndClosed)
	m.Load("sndBufInQueue", &x.sndBufInQueue)
	m.Load("sndQueue", &x.sndQueue)
	m.Load("packetTooBigCount", &x.packetTooBigCount)
	m.Load("sndMTU", &x.sndMTU)
	m.Load("rcv", &x.rcv)
	m.Load("snd", &x.snd)
	m.LoadValue("acceptedChan", new(endpointChan), func(y interface{}) { x.loadAcceptedChan(y.(endpointChan)) })
	m.AfterLoad(x.afterLoad)
}

func (x *ErrSaveRejection) beforeSave() {}
func (x *ErrSaveRejection) save(m state.Map) {
	x.beforeSave()
	m.Save("Err", &x.Err)
}

func (x *ErrSaveRejection) afterLoad() {}
func (x *ErrSaveRejection) load(m state.Map) {
	m.Load("Err", &x.Err)
}

func (x *endpointChan) beforeSave() {}
func (x *endpointChan) save(m state.Map) {
	x.beforeSave()
	m.Save("buffer", &x.buffer)
	m.Save("cap", &x.cap)
}

func (x *endpointChan) afterLoad() {}
func (x *endpointChan) load(m state.Map) {
	m.Load("buffer", &x.buffer)
	m.Load("cap", &x.cap)
}

func (x *receiver) beforeSave() {}
func (x *receiver) save(m state.Map) {
	x.beforeSave()
	m.Save("ep", &x.ep)
	m.Save("rcvNxt", &x.rcvNxt)
	m.Save("rcvAcc", &x.rcvAcc)
	m.Save("rcvWndScale", &x.rcvWndScale)
	m.Save("closed", &x.closed)
	m.Save("pendingRcvdSegments", &x.pendingRcvdSegments)
	m.Save("pendingBufUsed", &x.pendingBufUsed)
	m.Save("pendingBufSize", &x.pendingBufSize)
}

func (x *receiver) afterLoad() {}
func (x *receiver) load(m state.Map) {
	m.Load("ep", &x.ep)
	m.Load("rcvNxt", &x.rcvNxt)
	m.Load("rcvAcc", &x.rcvAcc)
	m.Load("rcvWndScale", &x.rcvWndScale)
	m.Load("closed", &x.closed)
	m.Load("pendingRcvdSegments", &x.pendingRcvdSegments)
	m.Load("pendingBufUsed", &x.pendingBufUsed)
	m.Load("pendingBufSize", &x.pendingBufSize)
}

func (x *segmentHeap) save(m state.Map) {
	m.SaveValue("", ([]*segment)(*x))
}

func (x *segmentHeap) load(m state.Map) {
	m.LoadValue("", new([]*segment), func(y interface{}) { *x = (segmentHeap)(y.([]*segment)) })
}

func (x *sender) beforeSave() {}
func (x *sender) save(m state.Map) {
	x.beforeSave()
	m.Save("ep", &x.ep)
	m.Save("lastSendTime", &x.lastSendTime)
	m.Save("dupAckCount", &x.dupAckCount)
	m.Save("fr", &x.fr)
	m.Save("sndCwnd", &x.sndCwnd)
	m.Save("sndSsthresh", &x.sndSsthresh)
	m.Save("sndCAAckCount", &x.sndCAAckCount)
	m.Save("outstanding", &x.outstanding)
	m.Save("sndWnd", &x.sndWnd)
	m.Save("sndUna", &x.sndUna)
	m.Save("sndNxt", &x.sndNxt)
	m.Save("sndNxtList", &x.sndNxtList)
	m.Save("rttMeasureSeqNum", &x.rttMeasureSeqNum)
	m.Save("rttMeasureTime", &x.rttMeasureTime)
	m.Save("closed", &x.closed)
	m.Save("writeNext", &x.writeNext)
	m.Save("writeList", &x.writeList)
	m.Save("srtt", &x.srtt)
	m.Save("rttvar", &x.rttvar)
	m.Save("rto", &x.rto)
	m.Save("srttInited", &x.srttInited)
	m.Save("maxPayloadSize", &x.maxPayloadSize)
	m.Save("sndWndScale", &x.sndWndScale)
	m.Save("maxSentAck", &x.maxSentAck)
}

func (x *sender) afterLoad() {}
func (x *sender) load(m state.Map) {
	m.Load("ep", &x.ep)
	m.Load("lastSendTime", &x.lastSendTime)
	m.Load("dupAckCount", &x.dupAckCount)
	m.Load("fr", &x.fr)
	m.Load("sndCwnd", &x.sndCwnd)
	m.Load("sndSsthresh", &x.sndSsthresh)
	m.Load("sndCAAckCount", &x.sndCAAckCount)
	m.Load("outstanding", &x.outstanding)
	m.Load("sndWnd", &x.sndWnd)
	m.Load("sndUna", &x.sndUna)
	m.Load("sndNxt", &x.sndNxt)
	m.Load("sndNxtList", &x.sndNxtList)
	m.Load("rttMeasureSeqNum", &x.rttMeasureSeqNum)
	m.Load("rttMeasureTime", &x.rttMeasureTime)
	m.Load("closed", &x.closed)
	m.Load("writeNext", &x.writeNext)
	m.Load("writeList", &x.writeList)
	m.Load("srtt", &x.srtt)
	m.Load("rttvar", &x.rttvar)
	m.Load("rto", &x.rto)
	m.Load("srttInited", &x.srttInited)
	m.Load("maxPayloadSize", &x.maxPayloadSize)
	m.Load("sndWndScale", &x.sndWndScale)
	m.Load("maxSentAck", &x.maxSentAck)
}

func (x *fastRecovery) beforeSave() {}
func (x *fastRecovery) save(m state.Map) {
	x.beforeSave()
	m.Save("active", &x.active)
	m.Save("first", &x.first)
	m.Save("last", &x.last)
	m.Save("maxCwnd", &x.maxCwnd)
}

func (x *fastRecovery) afterLoad() {}
func (x *fastRecovery) load(m state.Map) {
	m.Load("active", &x.active)
	m.Load("first", &x.first)
	m.Load("last", &x.last)
	m.Load("maxCwnd", &x.maxCwnd)
}

func (x *segmentList) beforeSave() {}
func (x *segmentList) save(m state.Map) {
	x.beforeSave()
	m.Save("head", &x.head)
	m.Save("tail", &x.tail)
}

func (x *segmentList) afterLoad() {}
func (x *segmentList) load(m state.Map) {
	m.Load("head", &x.head)
	m.Load("tail", &x.tail)
}

func (x *segmentEntry) beforeSave() {}
func (x *segmentEntry) save(m state.Map) {
	x.beforeSave()
	m.Save("next", &x.next)
	m.Save("prev", &x.prev)
}

func (x *segmentEntry) afterLoad() {}
func (x *segmentEntry) load(m state.Map) {
	m.Load("next", &x.next)
	m.Load("prev", &x.prev)
}

func init() {
	state.Register("tcp.endpointState", (*endpointState)(nil), state.Fns{Save: (*endpointState).save, Load: (*endpointState).load})
	state.Register("tcp.SACKInfo", (*SACKInfo)(nil), state.Fns{Save: (*SACKInfo).save, Load: (*SACKInfo).load})
	state.Register("tcp.endpoint", (*endpoint)(nil), state.Fns{Save: (*endpoint).save, Load: (*endpoint).load})
	state.Register("tcp.ErrSaveRejection", (*ErrSaveRejection)(nil), state.Fns{Save: (*ErrSaveRejection).save, Load: (*ErrSaveRejection).load})
	state.Register("tcp.endpointChan", (*endpointChan)(nil), state.Fns{Save: (*endpointChan).save, Load: (*endpointChan).load})
	state.Register("tcp.receiver", (*receiver)(nil), state.Fns{Save: (*receiver).save, Load: (*receiver).load})
	state.Register("tcp.segmentHeap", (*segmentHeap)(nil), state.Fns{Save: (*segmentHeap).save, Load: (*segmentHeap).load})
	state.Register("tcp.sender", (*sender)(nil), state.Fns{Save: (*sender).save, Load: (*sender).load})
	state.Register("tcp.fastRecovery", (*fastRecovery)(nil), state.Fns{Save: (*fastRecovery).save, Load: (*fastRecovery).load})
	state.Register("tcp.segmentList", (*segmentList)(nil), state.Fns{Save: (*segmentList).save, Load: (*segmentList).load})
	state.Register("tcp.segmentEntry", (*segmentEntry)(nil), state.Fns{Save: (*segmentEntry).save, Load: (*segmentEntry).load})
}
